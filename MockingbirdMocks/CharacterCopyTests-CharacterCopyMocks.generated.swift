//
//  CharacterCopyTests-CharacterCopyMocks.generated.swift
//  CharacterCopy
//
//  Generated by Mockingbird v0.20.0.
//  DO NOT EDIT
//

@testable import CharacterCopy
@testable import Mockingbird
import Foundation
import Swift
import UIKit

private let mkbGenericStaticMockContext = Mockingbird.GenericStaticMockContext()

// MARK: - Mocked IDestinationProtocol
public final class IDestinationProtocolMock: CharacterCopy.IDestinationProtocol, Mockingbird.Mock {
  typealias MockingbirdSupertype = CharacterCopy.IDestinationProtocol
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "CharacterCopy"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    IDestinationProtocolMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `writeChar`(`char`: Character)
  public func `writeChar`(`char`: Character) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`writeChar`(`char`: Character) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`char`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Character) -> Void { return mkbImpl(`char`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`writeChar`(char: `char`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `writeChar`(`char`: @autoclosure () -> Character) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Character) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Character) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`writeChar`(`char`: Character) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`char`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked `writeChars`(`char`: [Character])
  public func `writeChars`(`char`: [Character]) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`writeChars`(`char`: [Character]) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`char`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? ([Character]) -> Void { return mkbImpl(`char`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`writeChars`(char: `char`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `writeChars`(`char`: @autoclosure () -> [Character]) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([Character]) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([Character]) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`writeChars`(`char`: [Character]) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`char`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns a concrete mock of `IDestinationProtocol`.
public func mock(_ type: CharacterCopy.IDestinationProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> IDestinationProtocolMock {
  return IDestinationProtocolMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked ISourceProtocol
public final class ISourceProtocolMock: CharacterCopy.ISourceProtocol, Mockingbird.Mock {
  typealias MockingbirdSupertype = CharacterCopy.ISourceProtocol
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "CharacterCopy"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    ISourceProtocolMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `readChar`()
  public func `readChar`() -> Character {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`readChar`() -> Character", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Character).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> Character { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Character = mkbObject.`readChar`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Character).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `readChar`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Character, Character> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Character, Character>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`readChar`() -> Character", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Character).self)))
  }

  // MARK: Mocked `readChars`(`count`: Int)
  public func `readChars`(`count`: Int) -> [Character] {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`readChars`(`count`: Int) -> [Character]", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`count`)], returnType: Swift.ObjectIdentifier(([Character]).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Int) -> [Character] { return mkbImpl(`count`) }
      if let mkbImpl = mkbImpl as? () -> [Character] { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: [Character] = mkbObject.`readChars`(count: `count`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: ([Character]).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `readChars`(`count`: @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> [Character], [Character]> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> [Character], [Character]>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`readChars`(`count`: Int) -> [Character]", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`count`)], returnType: Swift.ObjectIdentifier(([Character]).self)))
  }
}

/// Returns a concrete mock of `ISourceProtocol`.
public func mock(_ type: CharacterCopy.ISourceProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ISourceProtocolMock {
  return ISourceProtocolMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}
